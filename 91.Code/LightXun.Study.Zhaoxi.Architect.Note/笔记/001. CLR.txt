CLR 核心机制探讨：
1. 堆栈内存分配发生了什么？
1）堆和栈（托管堆）都存在于进程的虚拟内存中，为程序运行提供存储空间。
2）栈（Stack）是操作系统在建立线程时，为这个线程建立的存储区域。
2-1）栈中存储值类型。
2-2）栈上是先进后出原则。
2-3）栈是自维护的，当元素不在被使用会被抛出。
2-4）栈空间较小，访问速度快。
3）堆（Heap）是应用程序在运行的时候请求操作系统分配给自己的内存，是申请-给予的过程。由于从操作系统管理的内存分配，在分配和销毁时都要占用时间，所以用堆的效率低的多。
3-1）堆（也叫做托管堆）存储引用类型。
3-2）堆受垃圾处理器 GC 管理。
3-3）堆没有访问限制，按地址索引。
3-4）堆空间较大，访问速度没有栈快。

2. C# 与 IL 对比解读
2-1）IL 解读
2-1-1）Nop：如果修补操作码，则填充空间。尽管可能消耗处理周期，但未执行任何有意义的操作。
2-1-2）Ret：从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。
2-1-3）Ldstr：推送对元数据中存储的字符串的新对象引用。
2-1-4）Ldloca：将位于特定索引处的局部变量的地址加载到计算堆栈上。
2-1-5）Ldloca.S：将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。
2-1-6）Ldc.I4.S：将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。
2-1-7）Stfld：用新值替换在对象引用或指针的字段中存储的值。
2-1-8）Ldloc.0：将索引 0 处的局部变量加载到计算堆栈上。
2-1-9）Ldfld：查找对象中其引用当前位于计算堆栈的字段的值。
2-1-10）Ldflda：查找对象中其引用当前位于计算堆栈的字段的地址。
2-1-11）Stloc：从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。
2-2）Student student = new Sutdent("晓风残月");
2-2-1）先声明 晓风残月
2-2-2）计算空间-开辟空间
2-2-3）返回引用地址，通过地址就可以操作对象（才有this）
2-2-4）调用构造函数--构造函数只是为了初始化
2-2-5）构造函数返回引用
2-3）值类型 new 对象是发生了什么？
2-3-1）在线程栈上创建一个 ValPoint 类型的变量 vPoint1。
2-3-2）new ValPoint() 之前，将 vPoint1 压到栈上，new 操作符并不分配内存，也不是创建实例。它仅仅是调用了 ValPoint 结构的默认构造函数，根据构造函数去初始化 vPoint1 结构的所有字段。

3. GC 机制和优化
3-1）内存是有上限的，不可能无止境的分配空间，因此就产生了 GC（Garbage Collector）的需求
3-1-1）提高了软件开发的抽象度。
3-1-2）程序员可以将精力集中在实际的问题上，而不用分心来管理内存的问题。
3-1-3）可以使模块的接口更加的清晰，减小模块间的耦合。
3-1-4）大大减少了内存人为管理不当所带来的 BUG。
3-1-5）使内存管理更加高效。
3-2）总的来说就是 GC 可以使程序员从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。
3-3）什么样的对象需要垃圾回收？
3-3-1）托管资源
3-3-2）存在堆里（含值类型+引用类型）
3-3-3）托管资源一般是指被 CLR 控制的内存资源，这些资源的管理可以由 CLR 来控制，例如程序中分配的对象，作用域内的变量等，大部分对象都是托管资源。
3-3-4）非托管资源是 CLR 不能控制或者管理的部分，这些资源有很多，比如文件流，数据库的链接，系统的窗口句柄，打印机资源，需要调用 Dispose 方法。
3-3-5）栈里是不需要 GC 的，栈里是自管理的。
3-4）Mark-Compact 标记压缩法
3-4-1）阶段一：Mark-Sweep 标记清除阶段，先假设 heap 中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后 heap 中没有打标记的对象都是可以被回收的。
3-4-2）阶段二：Compact 压缩阶段，对象回收之后 heap 内存空间变得不连续，在 heap 中移动这些对象，使他们重新从 heap 基地址开始连续排列，类似于磁盘空间的碎片整理。 
3-5）三个假设
3-5-1）对象越新，生存期越短。
3-5-2）对象越老，生存期越长。
3-5-3）回收部分资源，快过全部回收。
3-6）分代策略
3-6-1）第一次，遍历全部对象，找出没有引用的，删除，剩下 1 代。
3-6-2）第二次，遍历 0 代，找出没有引用的，删除，剩下升级 1 代，如果还不够空间，才会遍历 1 代，没有引用的删除，还在被使用的，升级为 2 代，都不够才会检查 2 代，只有 0、1、2 三代。
3-7）各代空间大小
3-7-1）实际上是没有具体值的，由 CLR 管理。
3-7-2）初始化时就会给 0 代/ 1 代的预算，然后动态调节。
3-7-3）GC 后，对象几乎没有留存，那么就会减小预算，加快回收频率，每次速度快。
3-7-4）如果 GC 后，有很多对象留存，那么就会增加预算，降低回收频率，每次回收内容多。
3-7-5）如果空间不够，就会全面回收，再不够就 OutOfMemory 了。
3-8）什么时候 GC
3-8-1）new 对象时---临界点。
3-8-2）windows 报告内存不够。
3-8-3）GC.Collect 强制 GC。
3-8-4）程序退出或者卸载 AppDomain。
3-9） 怎么用 GC.Collect
3-9-1）大多数情况下，应该让 GC 自己决定回收时间，以更好的控制各代预算，也避免 GC 降低相应。
3-9-2）如果知道大量对象无效，可以手动 GC ，尤其是 2 代。
3-10）大对象策略
3-10-1）85000 字节为限。
3-10-2）独立的地址空间。
3-10-3）不会移动压缩大对象，成本高，但也造成了碎片。
3-10-4）总是 2 代对象。
3-11）垃圾回收模式
3-11-1）工作站：单线程回收
3-11-2）服务器：多区域并行回收


4. 结构体中的字段是可以不初始化对象，直接用的，属性不可以。

5. 引用类型在堆里面---堆的空间有限---连续摆放---字符串的长短变化---都会导致大量内存移动---而且要锁定线程进行操作---成本太高---所以字符串只有新增，不修改（OCP）---进而引入享元模式---节约空间