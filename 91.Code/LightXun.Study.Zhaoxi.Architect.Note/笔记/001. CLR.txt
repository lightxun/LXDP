CLR 核心机制探讨：
1. 堆栈内存分配发生了什么？
1）堆和栈（托管堆）都存在于进程的虚拟内存中，为程序运行提供存储空间。
2）栈（Stack）是操作系统在建立线程时，为这个线程建立的存储区域。
2-1）栈中存储值类型。
2-2）栈上是先进后出原则。
2-3）栈是自维护的，当元素不在被使用会被抛出。
2-4）栈空间较小，访问速度快。
3）堆（Heap）是应用程序在运行的时候请求操作系统分配给自己的内存，是申请-给予的过程。由于从操作系统管理的内存分配，在分配和销毁时都要占用时间，所以用堆的效率低的多。
3-1）堆（也叫做托管堆）存储引用类型。
3-2）堆受垃圾处理器 GC 管理。
3-3）堆没有访问限制，按地址索引。
3-4）堆空间较大，访问速度没有栈快。

2. C# 与 IL 对比解读
2-1）IL 解读
2-1-1）Nop：如果修补操作码，则填充空间。尽管可能消耗处理周期，但未执行任何有意义的操作。
2-1-2）Ret：从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。
2-1-3）Ldstr：推送对元数据中存储的字符串的新对象引用。
2-1-4）Ldloca：将位于特定索引处的局部变量的地址加载到计算堆栈上。
2-1-5）Ldloca.S：将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。
2-1-6）Ldc.I4.S：将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。
2-1-7）Stfld：用新值替换在对象引用或指针的字段中存储的值。
2-1-8）Ldloc.0：将索引 0 处的局部变量加载到计算堆栈上。
2-1-9）Ldfld：查找对象中其引用当前位于计算堆栈的字段的值。
2-1-10）Ldflda：查找对象中其引用当前位于计算堆栈的字段的地址。
2-1-11）Stloc：从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。
2-2）Student student = new Sutdent("晓风残月");
2-2-1）先声明 晓风残月
2-2-2）计算空间-开辟空间
2-2-3）返回引用地址，通过地址就可以操作对象（才有this）
2-2-4）调用构造函数--构造函数只是为了初始化
2-2-5）构造函数返回引用
2-3）值类型 new 对象是发生了什么？
2-3-1）在线程栈上创建一个 ValPoint 类型的变量 vPoint1。
2-3-2）new ValPoint() 之前，将 vPoint1 压到栈上，new 操作符并不分配内存，也不是创建实例。它仅仅是调用了 ValPoint 结构的默认构造函数，根据构造函数去初始化 vPoint1 结构的所有字段。

3. GC 机制和优化
3-1）内存是有上限的，不可能无止境的分配空间，因此就产生了 GC（Garbage Collector）的需求
3-1-1）提高了软件开发的抽象度。
3-1-2）程序员可以将精力集中在实际的问题上，而不用分心来管理内存的问题。
3-1-3）可以使模块的接口更加的清晰，减小模块间的耦合。
3-1-4）大大减少了内存人为管理不当所带来的 BUG。
3-1-5）使内存管理更加高效。
3-2）总的来说就是 GC 可以使程序员从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。
3-3）什么样的对象需要垃圾回收？
3-3-1）托管资源
3-3-2）存在堆里（含值类型+引用类型）
3-3-3）托管资源一般是指被 CLR 控制的内存资源，这些资源的管理可以由 CLR 来控制，例如程序中分配的对象，作用域内的变量等，大部分对象都是托管资源。
3-3-4）非托管资源是 CLR 不能控制或者管理的部分，这些资源有很多，比如文件流，数据库的链接，系统的窗口句柄，打印机资源，需要调用 Dispose 方法。
3-3-5）栈里是不需要 GC 的，栈里是自管理的。

4. 结构体中的字段是可以不初始化对象，直接用的，属性不可以。

5. 引用类型在堆里面---堆的空间有限---连续摆放---字符串的长短变化---都会导致大量内存移动---而且要锁定线程进行操作---成本太高---所以字符串只有新增，不修改（OCP）---进而引入享元模式---节约空间