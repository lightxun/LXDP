1. 订单系统在电商网站中扮演的角色
1) 订单系统与购物车系统一同控制着订单的流程, 对上连接着商品系统\价格系统\会员系统, 向下对接库存系统\风控系统\消息系统\物流系统
2) 订单的服务: 订单的主要功能是为用户提供购物的服务支持, 主要包括订单列表\订单详情\在线下单\订单支付等等
3) 订单的逻辑: 负责管理订单流程操作的各种细节, 是订单系统的核心, 涉及到订单状态规则\订单金额计算规则\库存增减规则等等

2. 订单系统核心功能, 业务流程
1) 交易凭证, 记录交易过程(订单信息)
1-1) 订单信息包括基础信息(单号, 订单状态, 订单类型)\产品(产品名称, 图片, 数量)\用户(账户, 收货地址, 联系方式)\价格(促销活动, 优惠券)\支付(第三方支付信息:流水单号, 支付金额, 支付状态, metadata 元数据)
2) 完成交易闭关(订单状态流转)
2-1) 购物车 [结→算] 订单已生成(pending) [支→付] 支付处理中(processing) [支付→成功] 交易已成功(completed) [买家→退货] 已退单(refund)
                      [买家↓取消]                [支付↓失败][重新↑支付]
                      订单已取消(cancelled)         交易已失败(declined)

3. 订单的状态处理
1) 购物车 [结→算] 订单已生成(pending) [支→付] 支付处理中(processing) [支付→成功] 交易已成功(completed) [买家→退货] 已退单(refund)
                   [买家↓取消]                [支付↓失败][重新↑支付]
                    订单已取消(cancelled)         交易已失败(declined)

4. 订单 API 接口设计
1) 下单\结算(很难实现 RESTful, 所以采用面向服务式): POST api/shoppingCart/checkout
2) 获得订单历史: GET api/orders
3) 获得订单: GET api/orders/{Id}
4) 购买支付(很难实现 RESTful, 所以采用面向服务式): POST api/orders/placeOrder

5. 订单的有限状态机
1) 一种用来进行对象行为建模的工具
2) 描述对象在它的生命周期内所经历的状态序列, 以及如何响应来自外界的各种事件
3) 建模应用行为\硬件电路系统设计\软件工程\编译器\网络协议\计算与语言的研究
4) 状态机 4 要素
4-1) 现态: 是指当前所处的状态
4-2) 条件(事件): 触发一个动作, 执行一次状态的迁移
4-3) 动作: 条件满足后执行的动作
4-4) 次态: 条件满足后要迁往的新状态
4-5) 样例
 |    现态    |            条件              |        动作       |          次态         |
 | 订单已生成 |   购物车非空, 用户点击结算   |      点击支付     |       支付处理中      |
 | 订单已取消 |      订单合法, 买家取消      |          -        |           -           |
 | 支付处理中 |   订单合法, 第三方处理支付   | 支付失败\支付成功 | 交易已失败\交易已成功 |
 | 交易已失败 |       第三方收付款失败       |      重新支付     |       支付处理中      |
 | 交易已成功 |       第三方收付款成功       |      买家退货     |         已退单        |
 |   已退单   | 订单合法, 言获成功, 买家退货 |          -        |           -           |

 6. 代码实现
 1) 在 NuGet 中搜索 Stateless 框架, 它可以实现状态机的自我创建和管理, 安装时需要与 .NET CORE 适配版本, 课程中 .NET CORE 3.1 对应 Stateless 5.1.1 (由于 Stateless 是基于 .NET 标准库所建立, 同时支持 .NET FRAMEWORK 和 .NET CORE, 在 Stateless 3.0 版本后开始支持 .NET CORE, 所以对应关系为 Stateless 3.0 → .NET CORE 1.0, Stateless 4.0 → .NET CORE 2.0, Stateless 5.0 → .NET 3.0)
 2) using Stateless; 订单模型中增加私有的状态机变量 StateMachine<订单状态_Enum, 订单状态触发动作_Enum> _machine; 
 3) 在订单中创建状态机初始化函数处理, _machine new StateMachine<订单状态_Enum, 订单状态触发动作_Enum>(订单状态_Enum.初始化状态);
 4) 给状态机配置触发动作和状态转换, machine.Configure(订单状态_Enum.初始化状态).Permit(订单状态触发动作_Enum.触发动作,订单状态_Enum.第二状态), 以此来配置其他状态
 5) 在订单构造函数中调用状态机初始化函数